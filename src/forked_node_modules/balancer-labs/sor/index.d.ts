import {
  BigNumber as BigNumber$1,
  BigNumberish
} from '@ethersproject/bignumber';
import { Provider } from '@ethersproject/providers';
import { BigNumber } from 'bignumber.js';
export { BigNumber as OldBigNumber } from 'bignumber.js';
import { Contract } from '@ethersproject/contracts';
import { StablePoolPairData as StablePoolPairData$1 } from 'pools/stablePool/stablePool';

declare const ZERO: BigNumber;
declare function bnum(val: string | number | BigNumber): BigNumber;

interface SorConfig {
  chainId: number;
  vault: string;
  weth: string;
  bbausd?: {
    id: string;
    address: string;
  };
  wethBBausd?: {
    id: string;
    address: string;
  };
  staBal3Pool?: {
    id: string;
    address: string;
  };
  wethStaBal3?: {
    id: string;
    address: string;
  };
  usdcConnectingPool?: {
    id: string;
    usdc: string;
  };
  lbpRaisingTokens?: string[];
}
declare type NoNullableField<T> = {
  [P in keyof T]: NonNullable<T[P]>;
};
declare enum SwapTypes {
  SwapExactIn = 0,
  SwapExactOut = 1
}
declare enum PoolTypes {
  Weighted = 0,
  Stable = 1,
  Element = 2,
  MetaStable = 3,
  Linear = 4,
  Gyro2 = 5,
  Gyro3 = 6
}
interface SwapOptions {
  gasPrice: BigNumber$1;
  swapGas: BigNumber$1;
  timestamp: number;
  maxPools: number;
  poolTypeFilter: PoolFilter;
  forceRefresh: boolean;
}
declare type PoolPairBase = {
  id: string;
  address: string;
  poolType: PoolTypes;
  swapFee: BigNumber$1;
  tokenIn: string;
  tokenOut: string;
  decimalsIn: number;
  decimalsOut: number;
  balanceIn: BigNumber$1;
  balanceOut: BigNumber$1;
};
interface Swap {
  pool: string;
  tokenIn: string;
  tokenOut: string;
  swapAmount?: string;
  limitReturnAmount?: string;
  maxPrice?: string;
  tokenInDecimals: number;
  tokenOutDecimals: number;
}
interface SubgraphPoolBase {
  id: string;
  address: string;
  poolType: string;
  swapFee: string;
  swapEnabled: boolean;
  totalShares: string;
  tokens: SubgraphToken[];
  tokensList: string[];
  totalWeight?: string;
  amp?: string;
  expiryTime?: number;
  unitSeconds?: number;
  principalToken?: string;
  baseToken?: string;
  mainIndex?: number;
  wrappedIndex?: number;
  lowerTarget?: string;
  upperTarget?: string;
  gyro2PriceBounds?: Gyro2PriceBounds;
  gyro3PriceBounds?: Gyro3PriceBounds;
}
declare type SubgraphToken = {
  address: string;
  balance: string;
  decimals: number;
  priceRate: string;
  weight: string | null;
};
interface SwapV2 {
  poolId: string;
  assetInIndex: number;
  assetOutIndex: number;
  amount: string;
  userData: string;
}
interface SwapInfo {
  tokenAddresses: string[];
  swaps: SwapV2[];
  swapAmount: BigNumber$1;
  swapAmountForSwaps?: BigNumber$1;
  returnAmount: BigNumber$1;
  returnAmountFromSwaps?: BigNumber$1;
  returnAmountConsideringFees: BigNumber$1;
  tokenIn: string;
  tokenOut: string;
  marketSp: string;
}
interface PoolDictionary {
  [poolId: string]: PoolBase;
}
interface PoolPairDictionary {
  [tokenInOut: string]: PoolPairBase;
}
interface hopDictionary {
  [hopToken: string]: Set<string>;
}
interface NewPath {
  id: string;
  swaps: Swap[];
  poolPairData: PoolPairBase[];
  limitAmount: BigNumber$1;
  pools: PoolBase[];
  filterEffectivePrice?: BigNumber;
}
declare enum PoolFilter {
  All = 'All',
  Weighted = 'Weighted',
  Stable = 'Stable',
  MetaStable = 'MetaStable',
  LBP = 'LiquidityBootstrapping',
  Investment = 'Investment',
  Element = 'Element',
  AaveLinear = 'AaveLinear',
  StablePhantom = 'StablePhantom',
  ERC4626Linear = 'ERC4626Linear'
}
interface PoolBase {
  poolType: PoolTypes;
  id: string;
  address: string;
  tokensList: string[];
  mainIndex?: number;
  isLBP?: boolean;
  parsePoolPairData: (tokenIn: string, tokenOut: string) => PoolPairBase;
  getNormalizedLiquidity: (poolPairData: PoolPairBase) => BigNumber;
  getLimitAmountSwap: (
    poolPairData: PoolPairBase,
    swapType: SwapTypes
  ) => BigNumber;
  /**
   * @param {string} token - Address of token.
   * @param {BigNumber} newBalance - New balance of token. EVM scaled.
   */
  updateTokenBalanceForPool: (token: string, newBalance: BigNumber$1) => void;
  _exactTokenInForTokenOut: (
    poolPairData: PoolPairBase,
    amount: BigNumber
  ) => BigNumber;
  _tokenInForExactTokenOut: (
    poolPairData: PoolPairBase,
    amount: BigNumber
  ) => BigNumber;
  _spotPriceAfterSwapExactTokenInForTokenOut: (
    poolPairData: PoolPairBase,
    amount: BigNumber
  ) => BigNumber;
  _spotPriceAfterSwapTokenInForExactTokenOut: (
    poolPairData: PoolPairBase,
    amount: BigNumber
  ) => BigNumber;
  _derivativeSpotPriceAfterSwapExactTokenInForTokenOut: (
    poolPairData: PoolPairBase,
    amount: BigNumber
  ) => BigNumber;
  _derivativeSpotPriceAfterSwapTokenInForExactTokenOut: (
    poolPairData: PoolPairBase,
    amount: BigNumber
  ) => BigNumber;
}
interface TokenPriceService {
  /**
   * This should return the price of the native asset (ETH) in the token defined by tokenAddress.
   * Example: BAL = $20 USD, ETH = $4,000 USD, then 1 ETH = 200 BAL. This function would return 200.
   * @param tokenAddress
   */
  getNativeAssetPriceInToken(tokenAddress: string): Promise<string>;
}
interface PoolDataService {
  getPools(): Promise<SubgraphPoolBase[]>;
}
declare type Gyro2PriceBounds = {
  lowerBound: string;
  upperBound: string;
  tokenInAddress: string;
  tokenOutAddress: string;
};
declare type Gyro3PriceBounds = {
  alpha: string;
};

declare class RouteProposer {
  private readonly config;
  cache: Record<
    string,
    {
      paths: NewPath[];
    }
  >;
  constructor(config: SorConfig);
  /**
   * Given a list of pools and a desired input/output, returns a set of possible paths to route through
   */
  getCandidatePaths(
    tokenIn: string,
    tokenOut: string,
    swapType: SwapTypes,
    pools: SubgraphPoolBase[],
    swapOptions: SwapOptions
  ): NewPath[];
  /**
   * Given a pool dictionary and a desired input/output, returns a set of possible paths to route through.
   * @param {string} tokenIn - Address of tokenIn
   * @param {string} tokenOut - Address of tokenOut
   * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.
   * @param {PoolDictionary} poolsAllDict - Dictionary of pools.
   * @param {number }maxPools - Maximum number of pools to hop through.
   * @returns {NewPath[]} Array of possible paths sorted by liquidity.
   */
  getCandidatePathsFromDict(
    tokenIn: string,
    tokenOut: string,
    swapType: SwapTypes,
    poolsAllDict: PoolDictionary,
    maxPools: number
  ): NewPath[];
}

declare class SwapCostCalculator {
  private readonly tokenPriceService;
  private readonly tokenPriceCache;
  constructor(config: SorConfig, tokenPriceService: TokenPriceService);
  /**
   * Calculate the cost of spending a certain amount of gas in terms of a token.
   * This allows us to determine whether an increased amount of tokens gained
   * is worth spending this extra gas (e.g. by including an extra pool in a swap)
   */
  convertGasCostToToken(
    tokenAddress: string,
    tokenDecimals: number,
    gasPriceWei: BigNumber$1,
    swapGas?: BigNumber$1
  ): Promise<BigNumber$1>;
  /**
   * @param tokenAddress - the address of the token for which to express the native asset in terms of
   * @param tokenPrice - the price of the native asset in terms of the provided token
   */
  setNativeAssetPriceInToken(tokenAddress: string, tokenPrice: string): void;
  /**
   * @param tokenAddress - the address of the token for which to express the native asset in terms of
   */
  private getNativeAssetPriceInToken;
}

declare class SOR {
  provider: Provider;
  private readonly config;
  private readonly poolCacher;
  readonly routeProposer: RouteProposer;
  readonly swapCostCalculator: SwapCostCalculator;
  private readonly defaultSwapOptions;
  /**
   * @param {Provider} provider - Provider.
   * @param {SorConfig} config - Chain specific configuration for the SOR.
   * @param {PoolDataService} poolDataService - Generic service that fetches pool data from an external data source.
   * @param {TokenPriceService} tokenPriceService - Generic service that fetches token prices from an external price feed. Used in calculating swap cost.
   */
  constructor(
    provider: Provider,
    config: SorConfig,
    poolDataService: PoolDataService,
    tokenPriceService: TokenPriceService
  );
  getPools(): SubgraphPoolBase[];
  /**
   * fetchPools Retrieves pools information and saves to internal pools cache.
   * @returns {boolean} True if pools fetched successfully, False if not.
   */
  fetchPools(): Promise<boolean>;
  /**
   * getSwaps Retrieve information for best swap tokenIn>tokenOut.
   * @param {string} tokenIn - Address of tokenIn.
   * @param {string} tokenOut - Address of tokenOut.
   * @param {SwapTypes} swapType - SwapExactIn where the amount of tokens in (sent to the Pool) is known or SwapExactOut where the amount of tokens out (received from the Pool) is known.
   * @param {BigNumberish} swapAmount - Either amountIn or amountOut depending on the `swapType` value.
   * @returns {SwapInfo} Swap information including return amount and swaps structure to be submitted to Vault.
   */
  getSwaps(
    tokenIn: string,
    tokenOut: string,
    swapType: SwapTypes,
    swapAmount: BigNumberish,
    swapOptions?: Partial<SwapOptions>
  ): Promise<SwapInfo>;
  /**
   * getCostOfSwapInToken Calculates and saves price of a swap in outputToken denomination. Used to determine if extra swaps are cost effective.
   * @param {string} outputToken - Address of outputToken.
   * @param {number} outputTokenDecimals - Decimals of outputToken.
   * @param {BigNumber} gasPrice - Gas price used to calculate cost.
   * @param {BigNumber} swapGas - Gas cost of a swap. Default=35000.
   * @returns {BigNumber} Price of a swap in outputToken denomination.
   */
  getCostOfSwapInToken(
    outputToken: string,
    outputTokenDecimals: number,
    gasPrice: BigNumber$1,
    swapGas?: BigNumber$1
  ): Promise<BigNumber$1>;
  private processSwaps;
  /**
   * Find optimal routes for trade from given candidate paths
   */
  private getBestPaths;
}

declare function BPTForTokensZeroPriceImpact$2(
  balances: BigNumberish[],
  decimals: number[],
  normalizedWeights: BigNumberish[],
  amounts: BigNumberish[],
  bptTotalSupply: BigNumberish
): BigNumber$1;

declare function BPTForTokensZeroPriceImpact$1(
  allBalances: BigNumberish[],
  decimals: number[],
  amounts: BigNumberish[], // This has to have the same lenght as allBalances
  bptTotalSupply: BigNumberish,
  amp: BigNumberish
): BigNumber$1;

declare function BPTForTokensZeroPriceImpact(
  allBalances: BigNumberish[], // assuming that BPT balance was removed
  decimals: number[], // This should be [18, 18, 18]
  amounts: BigNumberish[], // This has to have the same length as allBalances
  virtualBptSupply: BigNumberish,
  amp: BigNumberish,
  fee: BigNumberish,
  rates: BigNumberish[]
): BigNumber$1;

declare function queryBatchSwapTokensIn(
  sor: SOR,
  vaultContract: Contract,
  tokensIn: string[],
  amountsIn: BigNumberish[],
  tokenOut: string
): Promise<{
  amountTokenOut: string;
  swaps: SwapV2[];
  assets: string[];
}>;
declare function queryBatchSwapTokensOut(
  sor: SOR,
  vaultContract: Contract,
  tokenIn: string,
  amountsIn: BigNumberish[],
  tokensOut: string[]
): Promise<{
  amountTokensOut: string[];
  swaps: SwapV2[];
  assets: string[];
}>;

/**
 * @returns an array of deduplicated token addresses used in the provided swaps
 */
declare const getTokenAddressesForSwap: (swaps: Swap[]) => string[];
/**
 * Formats a sequence of swaps to the format expected by the Balance Vault.
 * @dev Intermediate swaps' amounts are replaced with the sentinel value of zero
 *      and exact output sequences are reversed.
 * @param swapKind - a SwapTypes enum for whether the swap has an exact input or exact output
 * @param sequence - a sequence of swaps which form a path from the input token to the output token
 * @param tokenAddresses - an array of all the token address which are involved in the batchSwap
 * @returns
 */
declare const formatSequence: (
  swapKind: SwapTypes,
  sequence: Swap[],
  tokenAddresses: string[]
) => SwapV2[];

declare function parseToPoolsDict(
  pools: SubgraphPoolBase[],
  timestamp: number
): PoolDictionary;

declare type WeightedPoolToken = Pick<
  NoNullableField<SubgraphToken>,
  'address' | 'balance' | 'decimals' | 'weight'
>;
declare type WeightedPoolPairData = PoolPairBase & {
  weightIn: BigNumber$1;
  weightOut: BigNumber$1;
};
declare class WeightedPool implements PoolBase {
  poolType: PoolTypes;
  id: string;
  address: string;
  swapFee: BigNumber$1;
  totalShares: BigNumber$1;
  tokens: WeightedPoolToken[];
  totalWeight: BigNumber$1;
  tokensList: string[];
  MAX_IN_RATIO: BigNumber$1;
  MAX_OUT_RATIO: BigNumber$1;
  isLBP: boolean;
  static fromPool(pool: SubgraphPoolBase, isLBP?: boolean): WeightedPool;
  constructor(
    id: string,
    address: string,
    swapFee: string,
    totalWeight: string,
    totalShares: string,
    tokens: WeightedPoolToken[],
    tokensList: string[]
  );
  parsePoolPairData(tokenIn: string, tokenOut: string): WeightedPoolPairData;
  getNormalizedLiquidity(poolPairData: WeightedPoolPairData): BigNumber;
  getLimitAmountSwap(
    poolPairData: PoolPairBase,
    swapType: SwapTypes
  ): BigNumber;
  updateTokenBalanceForPool(token: string, newBalance: BigNumber$1): void;
  _exactTokenInForTokenOut(
    poolPairData: WeightedPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _tokenInForExactTokenOut(
    poolPairData: WeightedPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: WeightedPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: WeightedPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: WeightedPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: WeightedPoolPairData,
    amount: BigNumber
  ): BigNumber;
}

declare type StablePoolToken = Pick<
  SubgraphToken,
  'address' | 'balance' | 'decimals'
>;
declare type StablePoolPairData = PoolPairBase & {
  allBalances: BigNumber[];
  allBalancesScaled: BigNumber$1[];
  amp: BigNumber$1;
  tokenIndexIn: number;
  tokenIndexOut: number;
};
declare class StablePool implements PoolBase {
  poolType: PoolTypes;
  id: string;
  address: string;
  amp: BigNumber$1;
  swapFee: BigNumber$1;
  totalShares: BigNumber$1;
  tokens: StablePoolToken[];
  tokensList: string[];
  MAX_IN_RATIO: BigNumber$1;
  MAX_OUT_RATIO: BigNumber$1;
  static AMP_DECIMALS: number;
  static fromPool(pool: SubgraphPoolBase): StablePool;
  constructor(
    id: string,
    address: string,
    amp: string,
    swapFee: string,
    totalShares: string,
    tokens: StablePoolToken[],
    tokensList: string[]
  );
  parsePoolPairData(tokenIn: string, tokenOut: string): StablePoolPairData;
  getNormalizedLiquidity(poolPairData: StablePoolPairData): BigNumber;
  getLimitAmountSwap(
    poolPairData: PoolPairBase,
    swapType: SwapTypes
  ): BigNumber;
  updateTokenBalanceForPool(token: string, newBalance: BigNumber$1): void;
  _exactTokenInForTokenOut(
    poolPairData: StablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _tokenInForExactTokenOut(
    poolPairData: StablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: StablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: StablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: StablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: StablePoolPairData,
    amount: BigNumber
  ): BigNumber;
}

declare type MetaStablePoolToken = Pick<
  SubgraphToken,
  'address' | 'balance' | 'decimals' | 'priceRate'
>;
declare type MetaStablePoolPairData = StablePoolPairData$1 & {
  tokenInPriceRate: BigNumber$1;
  tokenOutPriceRate: BigNumber$1;
};
declare class MetaStablePool implements PoolBase {
  poolType: PoolTypes;
  id: string;
  address: string;
  amp: BigNumber$1;
  swapFee: BigNumber$1;
  totalShares: BigNumber$1;
  tokens: MetaStablePoolToken[];
  tokensList: string[];
  MAX_IN_RATIO: BigNumber$1;
  MAX_OUT_RATIO: BigNumber$1;
  static AMP_DECIMALS: number;
  static fromPool(pool: SubgraphPoolBase): MetaStablePool;
  constructor(
    id: string,
    address: string,
    amp: string,
    swapFee: string,
    totalShares: string,
    tokens: MetaStablePoolToken[],
    tokensList: string[]
  );
  parsePoolPairData(tokenIn: string, tokenOut: string): MetaStablePoolPairData;
  getNormalizedLiquidity(poolPairData: MetaStablePoolPairData): BigNumber;
  getLimitAmountSwap(
    poolPairData: MetaStablePoolPairData,
    swapType: SwapTypes
  ): BigNumber;
  updateTokenBalanceForPool(token: string, newBalance: BigNumber$1): void;
  _exactTokenInForTokenOut(
    poolPairData: MetaStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _tokenInForExactTokenOut(
    poolPairData: MetaStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: MetaStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: MetaStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: MetaStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: MetaStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
}

declare enum PairTypes$1 {
  BptToToken = 0,
  TokenToBpt = 1,
  TokenToToken = 2
}
declare type PhantomStablePoolToken = Pick<
  SubgraphToken,
  'address' | 'balance' | 'decimals' | 'priceRate'
>;
declare type PhantomStablePoolPairData = MetaStablePoolPairData & {
  pairType: PairTypes$1;
  bptIndex: number;
  virtualBptSupply: BigNumber$1;
};
declare class PhantomStablePool implements PoolBase {
  poolType: PoolTypes;
  id: string;
  address: string;
  amp: BigNumber$1;
  swapFee: BigNumber$1;
  totalShares: BigNumber$1;
  tokens: PhantomStablePoolToken[];
  tokensList: string[];
  ALMOST_ONE: BigNumber$1;
  MAX_TOKEN_BALANCE: BigNumber$1;
  static AMP_DECIMALS: number;
  static fromPool(pool: SubgraphPoolBase): PhantomStablePool;
  static removeBPT(
    poolPairData: PhantomStablePoolPairData
  ): PhantomStablePoolPairData;
  constructor(
    id: string,
    address: string,
    amp: string,
    swapFee: string,
    totalShares: string,
    tokens: PhantomStablePoolToken[],
    tokensList: string[]
  );
  parsePoolPairData(
    tokenIn: string,
    tokenOut: string
  ): PhantomStablePoolPairData;
  getNormalizedLiquidity(poolPairData: PhantomStablePoolPairData): BigNumber;
  getLimitAmountSwap(
    poolPairData: PhantomStablePoolPairData,
    swapType: SwapTypes
  ): BigNumber;
  updateTokenBalanceForPool(token: string, newBalance: BigNumber$1): void;
  _exactTokenInForTokenOut(
    poolPairData: PhantomStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _tokenInForExactTokenOut(
    poolPairData: PhantomStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: PhantomStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: PhantomStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: PhantomStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: PhantomStablePoolPairData,
    amount: BigNumber
  ): BigNumber;
  subtractSwapFeeAmount(amount: BigNumber$1, swapFee: BigNumber$1): BigNumber$1;
  addSwapFeeAmount(amount: BigNumber$1, swapFee: BigNumber$1): BigNumber$1;
}

declare enum PairTypes {
  BptToMainToken = 0,
  MainTokenToBpt = 1,
  MainTokenToWrappedToken = 2,
  WrappedTokenToMainToken = 3,
  BptToWrappedToken = 4,
  WrappedTokenToBpt = 5
}
declare type LinearPoolToken = Pick<
  SubgraphToken,
  'address' | 'balance' | 'decimals' | 'priceRate'
>;
declare type LinearPoolPairData = PoolPairBase & {
  pairType: PairTypes;
  wrappedBalance: BigNumber;
  wrappedBalanceScaled: BigNumber$1;
  wrappedDecimals: number;
  rate: BigNumber$1;
  lowerTarget: BigNumber$1;
  upperTarget: BigNumber$1;
  mainBalanceScaled: BigNumber$1;
  bptBalanceScaled: BigNumber$1;
  virtualBptSupply: BigNumber$1;
};
declare class LinearPool implements PoolBase {
  poolType: PoolTypes;
  id: string;
  address: string;
  swapFee: BigNumber$1;
  totalShares: BigNumber$1;
  tokens: LinearPoolToken[];
  tokensList: string[];
  wrappedIndex: number;
  wrappedDecimals: number;
  mainIndex: number;
  bptIndex: number;
  lowerTarget: BigNumber$1;
  upperTarget: BigNumber$1;
  MAX_RATIO: BigNumber$1;
  ALMOST_ONE: BigNumber$1;
  MAX_TOKEN_BALANCE: BigNumber$1;
  static fromPool(pool: SubgraphPoolBase): LinearPool;
  constructor(
    id: string,
    address: string,
    swapFee: string,
    totalShares: string,
    tokens: LinearPoolToken[],
    tokensList: string[],
    mainIndex: number,
    wrappedIndex: number,
    lowerTarget: string,
    upperTarget: string
  );
  parsePoolPairData(tokenIn: string, tokenOut: string): LinearPoolPairData;
  getNormalizedLiquidity(poolPairData: LinearPoolPairData): BigNumber;
  getLimitAmountSwap(
    poolPairData: LinearPoolPairData,
    swapType: SwapTypes
  ): BigNumber;
  updateTokenBalanceForPool(token: string, newBalance: BigNumber$1): void;
  _exactTokenInForTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _exactWrappedTokenInForMainOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _exactMainTokenInForWrappedOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _exactMainTokenInForBPTOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _exactBPTInForMainTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _exactWrappedTokenInForBPTOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _exactBPTInForWrappedTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _tokenInForExactTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _wrappedTokenInForExactMainOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _mainTokenInForExactWrappedOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _mainTokenInForExactBPTOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _BPTInForExactMainTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _wrappedTokenInForExactBPTOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _BPTInForExactWrappedTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _spotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapExactTokenInForTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
  _derivativeSpotPriceAfterSwapTokenInForExactTokenOut(
    poolPairData: LinearPoolPairData,
    amount: BigNumber
  ): BigNumber;
}

declare function getSpotPriceAfterSwapForPath(
  path: NewPath,
  swapType: SwapTypes,
  amount: BigNumber
): BigNumber;

export {
  bnum,
  formatSequence,
  getSpotPriceAfterSwapForPath,
  getTokenAddressesForSwap,
  Gyro2PriceBounds,
  Gyro3PriceBounds,
  hopDictionary,
  LinearPool,
  MetaStablePool,
  NewPath,
  NoNullableField,
  parseToPoolsDict,
  BPTForTokensZeroPriceImpact as phantomStableBPTForTokensZeroPriceImpact,
  PhantomStablePool,
  PoolBase,
  PoolDataService,
  PoolDictionary,
  PoolFilter,
  PoolPairBase,
  PoolPairDictionary,
  PoolTypes,
  queryBatchSwapTokensIn,
  queryBatchSwapTokensOut,
  RouteProposer,
  SOR,
  SorConfig,
  BPTForTokensZeroPriceImpact$1 as stableBPTForTokensZeroPriceImpact,
  StablePool,
  SubgraphPoolBase,
  SubgraphToken,
  Swap,
  SwapInfo,
  SwapOptions,
  SwapTypes,
  SwapV2,
  TokenPriceService,
  BPTForTokensZeroPriceImpact$2 as weightedBPTForTokensZeroPriceImpact,
  WeightedPool,
  ZERO
};
